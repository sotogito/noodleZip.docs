스프링은 **Observer 패턴**을 지원합니다.  
쉽게 말해 **어떤 이벤트가 발생했을 때, 관심 있는(구독하고 있는) 객체들이 자동으로 알림을 받고 처리하는 구조**입니다.

- **Publisher (발행자)**: 이벤트를 발생시킴
    
- **Listener (리스너)**: 이벤트를 감지하고, 발생 시 동작을 수행 - 메서드 단위
    
- **Event (이벤트 객체)**: 발생한 이벤트에 대한 정보(데이터)를 담음


| 어노테이션                         | 언제 실행됨?                                               |
| ----------------------------- | ----------------------------------------------------- |
| `@EventListener`              | **`publishEvent()` 호출되는 즉시** 실행됨 (즉, 그 메서드 안에서 바로 실행) |
| `@TransactionalEventListener` | **트랜잭션 커밋 후** 실행됨 (즉, 댓글이 DB에 저장이 확정된 다음에 실행)         |

| 어노테이션 조합                             | 언제 실행?                       | 비동기 적용 시점              |
| ------------------------------------ | ---------------------------- | ---------------------- |
| `@Async @EventListener`              | `publishEvent()` 호출 직후 즉시 실행 | 바로 별도 쓰레드에서 비동기로 실행    |
| `@Async @TransactionalEventListener` | 트랜잭션 `commit` 끝난 뒤 실행        | 커밋까지 기다린 뒤 별도 쓰레드에서 실행 |

# @Async + @TransactionalEventListener 주의사항

## 1️⃣ `@EnableAsync` 반드시 필요

- `@Async` 는 스프링 비동기 기능이기 때문에
    
- `@EnableAsync` 가 없으면 **전혀 비동기로 실행되지 않고 무시**돼요.
    

java

복사편집

`@Configuration @EnableAsync public class AsyncConfig { }`

✅ 없으면 `@Async` 는 그냥 동기로 실행됨.


| 주의할 점             | 설명                                                              |
| ----------------- | --------------------------------------------------------------- |
| `@EnableAsync` 필수 | 없으면 `@Async` 무시                                                 |
| 트랜잭션 전파 안 됨       | `@Async` 로 실행된 곳은 별도 트랜잭션, 같은 트랜잭션으로 롤백 못함                      |
| 커밋 이후만 실행         | rollback 되면 `AFTER_COMMIT` 은 아예 실행 안 됨                          |
| 쓰레드풀 확인           | 대규모에서 쓰레드풀이 다 차면 task 대기 or 거부될 수 있음 (필요시 `TaskExecutor` 튜닝 필요) |