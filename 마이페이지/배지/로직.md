
#### 적용 가장 상위 서비스
1. 증감형(배지카테고리)
2. 단발형(바로메서드적용)

상위 인퍼테이스를 enum에 적용 - badgeType
```
public interface BadgeType {
    String getName();
    int getLevel();
}
public enum RegionBadge implements BadgeType {
    EXPLORER(1, "골목 탐험가"),
    MASTER(5, "라멘 구단 마스터");

    private final int level;
    private final String name;

    RegionBadge(int level, String name) {
        this.level = level;
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public int getLevel() {
        return level;
    }
}

```

### 처리로직
- 리뷰 작성을 제외하고는 적당한 업데이트가 되는 부분에 심어주기 때문에 current_value값만 업데이트 해주면 된다. 즉, 리뷰 좋아요라면 리뷰 좋아요 쿼리를 날려서 하나하나 확인해줄 필요가 없다는 뜻이다. 단. 그 심은 곳에서 해당 사용자 배지의 타입을 같이 넘겨줘야한다. - 아니면 서비스 로직을 각각 맞게
- 배지 카테고리를 넘겨서 해당 배지 카테고리의 수를 증가시키고 배지를 매칭

- BadgeType(Enum)
	- 리뷰좋아요
	- 일반게시글작성
	- ...
- 리뷰 타입이 넘어올테고 BadgeLevel인터페이스로 묶인 enum을 리스트로 담아서 for문을 돌린다. 해당 enum 내부에는 각각의 배지타입에대한 getBadgeType메서드를 갖고있고 그것과 매개변수로 넘어온 배지 타입이 같을 경우 로직이 실행된다.
```
public enum ReviewLikeBadge implements BadgeLevel {
    ENTRY(10, "입맛 공유자", 1),
    PROMOTER(30, "미각 추천러", 2),
    // ...

    private final int threshold;
    private final String name;
    private final int level;

    ReviewLikeBadge(int threshold, String name, int level) {
        this.threshold = threshold;
        this.name = name;
        this.level = level;
    }

    @Override public int getThreshold() { return threshold; }
    @Override public String getName() { return name; }
    @Override public int getLevel() { return level; }
    @Override public BadgeType getBadgeType() { return BadgeType.REVIEW_LIKE; }
}

```


그 후 BadgeApplicator를 실행
만약 사용지+해당뱃지이름이 없다면 뱃지+진행테이블 생성
만약 있담녀 진행테이블 업데이트

- 배지 테이블
	- 뱃지 아이디
	- 배지 이미지
	- 뱃지 타입(Enum)
	- 뱃지 이름
	- 뱃지 레벨(nullable=단발)
	- 점수 기준
	- 설명

- 레벨 카테고리에 필요한 값
	- 레벨 숫자로 1,2,3,4,5
	- 뱃지 이름
	- 뱃지


업데이트를 하는데. 
필요한 것은 해당 배지타입의 정보이다.
- current_value 업데이트
- 배지 상태를 업데이트 해야하는지 확인
- 마지막으로 배지 상태가 업데이트된 날짜

그럼 배지테이블에는 
- 배지아이디
- is_next : 만약 다음 레벨이 남았는지 - 배지의 레벨이 확잘될 수 있기 때문



